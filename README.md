# Hopfield Network 

**Authors**: Alessandro Fella, Lucia Depaoli, Lorenzo Mandolito and Simone Mistrali 

Project on Hopfield Network Model for Laboratory of Computational Physics at UniPD.

## Theory

A Hopefiled network is a form of recurrent artificial neural network  and a type of spin glass system (Disordered system) based on the Ising model. Hopfield networks serve as content-addressable ("associative") memory systems with binary threshold nodes, or with continuous variables. Hopfield networks also provide a model for understanding human memory.

This spin system has many nontrivial minima, it is  a neural
network where patterns are intentionally generated by an external agent, by encoding them in the coupling matrix <a href="https://www.codecogs.com/eqnedit.php?latex=J_{ij}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?J_{ij}" title="J_{ij}" /></a>between neurons, which are biologically realized by axons. In this case each <a href="https://www.codecogs.com/eqnedit.php?latex=J_{ij}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?J_{ij}" title="J_{ij}" /></a>  represents a synaptic efficiency, i.e. the kind of transmission of the axon from <a href="https://www.codecogs.com/eqnedit.php?latex=j" target="_blank"><img src="https://latex.codecogs.com/gif.latex?j" title="j" /></a> neuron to neuron <a href="https://www.codecogs.com/eqnedit.php?latex=i" target="_blank"><img src="https://latex.codecogs.com/gif.latex?i" title="i" /></a>. We will map neurons to spins and <a href="https://www.codecogs.com/eqnedit.php?latex=J_{ij}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?J_{ij}" title="J_{ij}" /></a> to their coupling, thus translating patterns into energetic minima.
Biologically, a neuron is activated when the incoming electrical signal overcomes a threshold. We define neuron states as

<img src="https://latex.codecogs.com/gif.latex?S_i&space;=&space;&plus;1\,&space;\text{(excited),&space;and&space;}&space;S_i&space;=&space;-1\text{&space;(at&space;rest)}" title="S_i = +1\, \text{(excited), and } S_i = -1\text{ (at rest)}" />

and a local field collecting all other impulses as

<img src="https://latex.codecogs.com/gif.latex?h_i&space;=\sum_{i=0}^NJ_{ij}&space;(S_j&space;&plus;&space;1)" title="h_i =\sum_{i=0}^NJ_{ij} (S_j + 1)" />

Given a pattern <a href="https://www.codecogs.com/eqnedit.php?latex=\xi^\mu=\left\{\xi^\mu_1,\dots,&space;\xi^\mu_N\right\}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\xi^\mu=\left\{\xi^\mu_1,\dots,&space;\xi^\mu_N\right\}" title="\xi^\mu=\left\{\xi^\mu_1,\dots, \xi^\mu_N\right\}" /></a>, with <a href="https://www.codecogs.com/eqnedit.php?latex=\xi^i_1=\left\{&plus;1,-1\right\}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\xi^i_1=\left\{&plus;1,-1\right\}" title="\xi^i_1=\left\{+1,-1\right\}" /></a>

, this is essentially a spin configuration. We can retrieve the couplings matrix in the following way:

<img src="https://latex.codecogs.com/gif.latex?J_{ij}=&space;\frac{1}{N}\sum_{\mu=0}^{P-1}\xi^\mu_i\xi^\mu_j" title="J_{ij}= \frac{1}{N}\sum_{\mu=0}^{P-1}\xi^\mu_i\xi^\mu_j" />

 where <img src="https://latex.codecogs.com/gif.latex?P" title="P" /> in the number of patterns. For semplicity we apply the so called *Hebbâ€™s rule*, so we neglect the auto-interation <a href="https://www.codecogs.com/eqnedit.php?latex=J_{ij}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?J_{ij}=0" title="J_{ij}=0" /></a>.

We use the following update rule (i.e *sign* rule):

<img src="https://latex.codecogs.com/gif.latex?S_i(t&plus;1)=\text{sng}\left[\sum_{j=1}^NJ_{ij}S_j(t)\right]" title="S_i(t+1)=\text{sng}\left[\sum_{j=1}^NJ_{ij}S_j(t)\right]" />

## Project

In this project we basically try to figure out if this type of model works fine using different patterns (1-D and 2-D), i.e given a corrupted pattern <img src="https://latex.codecogs.com/gif.latex?y^a" title="y^a" /> (i.e. a pattern <img src="https://latex.codecogs.com/gif.latex?y^a_i&space;=&space;\xi^a_i" title="y^a_i = \xi^a_i" /> with probability q<1 , otherwise <img src="https://latex.codecogs.com/gif.latex?y^a_i&space;=&space;-\xi^a_i" title="y^a_i = -\xi^a_i" /> with probability <img src="https://latex.codecogs.com/gif.latex?1-q" title="1-q" />) it can reconstruct the original pattern <img src="https://latex.codecogs.com/gif.latex?\xi^a" title="\xi^a" /> with the *sign* rule.

The first part shows a simple example using random generated patterns made by <img src="https://latex.codecogs.com/gif.latex?&plus;1" title="+1" /> and <img src="https://latex.codecogs.com/gif.latex?-1" title="-1" /> numbers and random corrupted patterns, defined by a grade of corruption <img src="https://latex.codecogs.com/gif.latex?q" title="q" /> respect to the original ones. We have see the averaged mean of pattern retrived by varying the number of patterns given different probability of corruption. 

The second part is focused on a simple 2-D toy model, we use as a pattern the number of the handwritten MINST database. We try different approach:

- We use the vanilla database with poor results.
- We crop the images and in this case we can see that the model can correct retrieve up to 5 images using <img src="https://latex.codecogs.com/gif.latex?10\times&space;10" title="10\times 10" />  images.
- We crop and vary the number of patterns.
- We crop the images to <img src="https://latex.codecogs.com/gif.latex?14\times&space;14" title="14\times 14" /> pixels and apply a so called *nearest neighbor* <img src="https://latex.codecogs.com/gif.latex?J" title="J" />, we set to 0 the interaction between pixels which are farther away than a given distance.

## Requirements & Contact

To properly run this project please clone this directory and from a terminal run this command:

``` python3 -m pip install -r requirements.txt```

Contact Simone Mistrali at simone.mistrali at gmail.com for any questions or comments.

To properly see the formulas please set the light theme on Github settings.
